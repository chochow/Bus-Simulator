/**
 *
 * @Copyright 2019 3081 Staff, All rights reserved.
 *
 * STUDENTS:  DO NOT EDIT THIS FILE.  INSTEAD, MODIFY YOUR OWN PROJECT
 * CODE TO FIT THE SPECIFICATION GIVEN BY THE TESTS IN THIS FILE.
 *
 * If you DO modify it, we overwrite it with a fresh version from our repo
 * when grading, so you can't use it to fudge the tests anyway.
 *
 * This file is used by the CS3081W auto-grading system.
 *
 * Please note, the assessment tests for grading, will use the same include
 * files, class names, and function names for accessing students' code that you
 * find in this file.  So students, if you write your code so that it passes
 * these feedback tests, you can be assured that the auto-grader will at least
 * be able to properly link with your code.
 */

/*******************************************************************************
 * Includes
 ******************************************************************************/
#include <gtest/gtest.h>
#include <iostream>
#include <vector>
#include <list>
#include <random>
#include <ctime>
#include <fstream>
#include <string>
#include "../src/bus.h"
#include "../src/mypassenger_gen.h"
#include "../src/passenger.h"
#include "../src/route.h"
#include "../src/stop.h"
/******************************************************
* TEST FEATURE SetUp
*******************************************************/

class BusTests : public ::testing::Test {
 protected:
    Bus* campus_connector1;


    virtual void SetUp() {
        Stop ** CC_EB_stops = new Stop *[4];
        Stop ** CC_WB_stops = new Stop *[4];
        std::list<Stop *> CC_EB_stops_list;
        std::list<Stop *> CC_WB_stops_list;

        Stop * stop_CC_EB_1 = new Stop(0, 44.972392, -93.243774);
        //   student union station
        Stop * stop_CC_EB_2 = new Stop(1, 44.973580, -93.235071);
        //   Oak St & Washington Ave
        Stop * stop_CC_EB_3 = new Stop(2, 44.975392, -93.226632);
        //   before transit
        Stop * stop_CC_EB_4 = new Stop(3, 44.975837, -93.222174);

        Stop * stop_CC_WB_1 = new Stop(8, 44.984630, -93.186352);
    //   Buford & Gartner
        Stop * stop_CC_WB_2 = new Stop(9, 44.984482, -93.181657);
        //   Fairgrounds
        Stop * stop_CC_WB_3 = new Stop(10, 44.983703, -93.178846);
        //   Tway
        Stop * stop_CC_WB_4 = new Stop(11, 44.980663, -93.180808);

        CC_EB_stops_list.push_back(stop_CC_EB_1);
        CC_EB_stops[0] = stop_CC_EB_1;
        CC_EB_stops_list.push_back(stop_CC_EB_2);
        CC_EB_stops[1] = stop_CC_EB_2;
        CC_EB_stops_list.push_back(stop_CC_EB_3);
        CC_EB_stops[2] = stop_CC_EB_3;
        CC_EB_stops_list.push_back(stop_CC_EB_4);
        CC_EB_stops[3] = stop_CC_EB_4;

        CC_WB_stops_list.push_back(stop_CC_WB_1);
        CC_WB_stops[0] = stop_CC_WB_1;
        CC_WB_stops_list.push_back(stop_CC_WB_2);
        CC_WB_stops[1] = stop_CC_WB_2;
        CC_WB_stops_list.push_back(stop_CC_WB_3);
        CC_WB_stops[2] = stop_CC_WB_3;
        CC_WB_stops_list.push_back(stop_CC_WB_4);
        CC_WB_stops[3] = stop_CC_WB_4;

        double * CC_EB_distances = new double[4];
        double * CC_WB_distances = new double[4];
        CC_EB_distances[0] = 2;
        CC_EB_distances[1] = 2;
        CC_EB_distances[2] = 2;
        CC_EB_distances[3] = 2;

        CC_WB_distances[0] = 2;
        CC_WB_distances[1] = 2;
        CC_WB_distances[2] = 2;
        CC_WB_distances[3] = 2;

        std::list<double> CC_EB_probs;  // realistic .15, .3, .025, .05, .05, 0
        CC_EB_probs.push_back(.15);   // WB
        CC_EB_probs.push_back(.3);    // CMU
        CC_EB_probs.push_back(.025);  // O&W
        CC_EB_probs.push_back(.05);   // Pre-transit

        std::list<double> CC_WB_probs;  // realistic .35, .05, .01, .01, .2, 0
        CC_WB_probs.push_back(.35);     // SPSC
        CC_WB_probs.push_back(.05);     // Buford
        CC_WB_probs.push_back(.01);     // State fair
        CC_WB_probs.push_back(.01);


        MyPassengerGen * CC_EB_generator
            = new MyPassengerGen(CC_EB_probs, CC_EB_stops_list);
        MyPassengerGen * CC_WB_generator
            = new MyPassengerGen(CC_WB_probs, CC_WB_stops_list);


        CC_EB_generator->GeneratePassengers();
        CC_WB_generator->GeneratePassengers();

        Route * CC_EB = new Route("Campus Connector - Eastbound", CC_EB_stops,
                            CC_EB_distances, 4, CC_EB_generator);
        Route * CC_WB = new Route("Campus Connector - Westbound", CC_WB_stops,
                            CC_WB_distances, 4, CC_WB_generator);

        campus_connector1 = new Bus ("bus1", CC_EB, CC_WB, 60, 1);
    }

        virtual void TearDown() {
        delete campus_connector1;
    }
};


TEST_F(BusTests, ConstructorTest) {
    Bus * bus2;
    bus2 = new Bus("bus1", NULL, NULL, 2, 1);
    testing::internal::CaptureStdout();
    campus_connector1->Report(std::cout);
    std::string output = testing::internal::GetCapturedStdout();
    EXPECT_EQ(output,
    "Name: bus1\nSpeed: 1\nDistance to next stop: 0\n\tPassengers (0): \n");
    campus_connector1->UpdateBusData();
    BusData bus_data = campus_connector1->GetBusData();
    EXPECT_EQ(bus_data.id, "bus1");
	EXPECT_FLOAT_EQ(bus_data.position.x, 44.972392);
	EXPECT_FLOAT_EQ(bus_data.position.y, -93.243774);
	EXPECT_EQ(bus_data.num_passengers, 0);
    EXPECT_EQ(bus_data.capacity, 60);

}

TEST_F(BusTests, LoadPassengerTest) {
    Bus * bus2;
    bus2 = new Bus("bus1", NULL, NULL, 2, 1);
    EXPECT_EQ(bus2->LoadPassenger(new Passenger(3, "shin")), true);
    bus2->LoadPassenger(new Passenger(2, "yuyu"));
    EXPECT_EQ(bus2->LoadPassenger(new Passenger(5, "chochow")), false);
}


TEST_F(BusTests, UnloadPassengerTest) {
    Bus* bus2;
    Stop ** CC_EB_stops = new Stop *[2];
    std::list<Stop *> CC_EB_stops_list;
    Stop * stop_CC_EB_1 = new Stop(0, 44.972392, -93.243774);
    //   student union station
    Stop * stop_CC_EB_2 = new Stop(1, 44.973580, -93.235071);

    stop_CC_EB_1->AddPassengers(new Passenger(1, "whoisthere"));
    stop_CC_EB_2->AddPassengers(new Passenger(1, "whoisthere"));

    CC_EB_stops_list.push_back(stop_CC_EB_1);
    CC_EB_stops[0] = stop_CC_EB_1;
    CC_EB_stops_list.push_back(stop_CC_EB_2);
    CC_EB_stops[1] = stop_CC_EB_2;
    double * CC_EB_distances = new double[2];
    CC_EB_distances[0] = 2;
    CC_EB_distances[1] = 2;

    std::list<double> CC_EB_probs;  // realistic .15, .3, .025, .05, .05, 0
    CC_EB_probs.push_back(.15);   // WB
    CC_EB_probs.push_back(.3);
    MyPassengerGen * CC_EB_generator
            = new MyPassengerGen(CC_EB_probs, CC_EB_stops_list);
    CC_EB_generator->GeneratePassengers();
    Route * CC_EB = new Route("Campus Connector - Eastbound", CC_EB_stops,
                            CC_EB_distances, 2, CC_EB_generator);
    bus2 = new Bus ("bus1", CC_EB, NULL, 60, 1);

    EXPECT_EQ(bus2->UnLoadPassenger(), false);
    bus2->LoadPassenger(new Passenger(0, "whoisthere"));
    EXPECT_EQ(bus2->UnLoadPassenger(), true);
}


TEST_F(BusTests, IsTripCompleteTest) {
    EXPECT_EQ(campus_connector1->IsTripComplete(), false);
    for (int i = 0; i < 16; i++) {
        campus_connector1->Update();
    }
    EXPECT_EQ(campus_connector1->IsTripComplete(), true);
}


TEST_F(BusTests, UpdateTest) {
    EXPECT_EQ(campus_connector1->IsTripComplete(), false);
    for (int i = 0; i < 20; i++) {
        campus_connector1->Update();
    }
    EXPECT_EQ(campus_connector1->IsTripComplete(), true);
}

